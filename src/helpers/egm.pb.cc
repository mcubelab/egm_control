// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "egm.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace abb {
namespace egm {

namespace {

const ::google::protobuf::Descriptor* EgmHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmHeader_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* EgmHeader_MessageType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* EgmCartesian_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmCartesian_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmQuaternion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmQuaternion_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmEuler_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmEuler_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmCartesianSpeed_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmCartesianSpeed_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmJoints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmJoints_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmExternalJoints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmExternalJoints_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmPlanned_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmPlanned_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmSpeedRef_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmSpeedRef_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmPathCorr_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmPathCorr_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmFeedBack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmFeedBack_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmMotorState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmMotorState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* EgmMotorState_MotorStateType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* EgmMCIState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmMCIState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* EgmMCIState_MCIStateType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* EgmRapidCtrlExecState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmRapidCtrlExecState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* EgmTestSignals_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmTestSignals_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmRobot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmRobot_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmSensor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmSensor_reflection_ = NULL;
const ::google::protobuf::Descriptor* EgmSensorPathCorr_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EgmSensorPathCorr_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_egm_2eproto() {
  protobuf_AddDesc_egm_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "egm.proto");
  GOOGLE_CHECK(file != NULL);
  EgmHeader_descriptor_ = file->message_type(0);
  static const int EgmHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmHeader, seqno_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmHeader, tm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmHeader, mtype_),
  };
  EgmHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmHeader_descriptor_,
      EgmHeader::default_instance_,
      EgmHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmHeader));
  EgmHeader_MessageType_descriptor_ = EgmHeader_descriptor_->enum_type(0);
  EgmCartesian_descriptor_ = file->message_type(1);
  static const int EgmCartesian_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesian, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesian, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesian, z_),
  };
  EgmCartesian_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmCartesian_descriptor_,
      EgmCartesian::default_instance_,
      EgmCartesian_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesian, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesian, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmCartesian));
  EgmQuaternion_descriptor_ = file->message_type(2);
  static const int EgmQuaternion_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmQuaternion, u0_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmQuaternion, u1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmQuaternion, u2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmQuaternion, u3_),
  };
  EgmQuaternion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmQuaternion_descriptor_,
      EgmQuaternion::default_instance_,
      EgmQuaternion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmQuaternion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmQuaternion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmQuaternion));
  EgmEuler_descriptor_ = file->message_type(3);
  static const int EgmEuler_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmEuler, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmEuler, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmEuler, z_),
  };
  EgmEuler_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmEuler_descriptor_,
      EgmEuler::default_instance_,
      EgmEuler_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmEuler, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmEuler, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmEuler));
  EgmPose_descriptor_ = file->message_type(4);
  static const int EgmPose_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPose, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPose, orient_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPose, euler_),
  };
  EgmPose_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmPose_descriptor_,
      EgmPose::default_instance_,
      EgmPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPose, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPose, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmPose));
  EgmCartesianSpeed_descriptor_ = file->message_type(5);
  static const int EgmCartesianSpeed_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesianSpeed, value_),
  };
  EgmCartesianSpeed_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmCartesianSpeed_descriptor_,
      EgmCartesianSpeed::default_instance_,
      EgmCartesianSpeed_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesianSpeed, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmCartesianSpeed, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmCartesianSpeed));
  EgmJoints_descriptor_ = file->message_type(6);
  static const int EgmJoints_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmJoints, joints_),
  };
  EgmJoints_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmJoints_descriptor_,
      EgmJoints::default_instance_,
      EgmJoints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmJoints, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmJoints, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmJoints));
  EgmExternalJoints_descriptor_ = file->message_type(7);
  static const int EgmExternalJoints_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmExternalJoints, joints_),
  };
  EgmExternalJoints_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmExternalJoints_descriptor_,
      EgmExternalJoints::default_instance_,
      EgmExternalJoints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmExternalJoints, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmExternalJoints, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmExternalJoints));
  EgmPlanned_descriptor_ = file->message_type(8);
  static const int EgmPlanned_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPlanned, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPlanned, cartesian_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPlanned, externaljoints_),
  };
  EgmPlanned_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmPlanned_descriptor_,
      EgmPlanned::default_instance_,
      EgmPlanned_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPlanned, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPlanned, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmPlanned));
  EgmSpeedRef_descriptor_ = file->message_type(9);
  static const int EgmSpeedRef_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSpeedRef, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSpeedRef, cartesians_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSpeedRef, externaljoints_),
  };
  EgmSpeedRef_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmSpeedRef_descriptor_,
      EgmSpeedRef::default_instance_,
      EgmSpeedRef_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSpeedRef, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSpeedRef, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmSpeedRef));
  EgmPathCorr_descriptor_ = file->message_type(10);
  static const int EgmPathCorr_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPathCorr, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPathCorr, age_),
  };
  EgmPathCorr_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmPathCorr_descriptor_,
      EgmPathCorr::default_instance_,
      EgmPathCorr_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPathCorr, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmPathCorr, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmPathCorr));
  EgmFeedBack_descriptor_ = file->message_type(11);
  static const int EgmFeedBack_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmFeedBack, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmFeedBack, cartesian_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmFeedBack, externaljoints_),
  };
  EgmFeedBack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmFeedBack_descriptor_,
      EgmFeedBack::default_instance_,
      EgmFeedBack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmFeedBack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmFeedBack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmFeedBack));
  EgmMotorState_descriptor_ = file->message_type(12);
  static const int EgmMotorState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmMotorState, state_),
  };
  EgmMotorState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmMotorState_descriptor_,
      EgmMotorState::default_instance_,
      EgmMotorState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmMotorState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmMotorState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmMotorState));
  EgmMotorState_MotorStateType_descriptor_ = EgmMotorState_descriptor_->enum_type(0);
  EgmMCIState_descriptor_ = file->message_type(13);
  static const int EgmMCIState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmMCIState, state_),
  };
  EgmMCIState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmMCIState_descriptor_,
      EgmMCIState::default_instance_,
      EgmMCIState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmMCIState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmMCIState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmMCIState));
  EgmMCIState_MCIStateType_descriptor_ = EgmMCIState_descriptor_->enum_type(0);
  EgmRapidCtrlExecState_descriptor_ = file->message_type(14);
  static const int EgmRapidCtrlExecState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRapidCtrlExecState, state_),
  };
  EgmRapidCtrlExecState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmRapidCtrlExecState_descriptor_,
      EgmRapidCtrlExecState::default_instance_,
      EgmRapidCtrlExecState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRapidCtrlExecState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRapidCtrlExecState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmRapidCtrlExecState));
  EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor_ = EgmRapidCtrlExecState_descriptor_->enum_type(0);
  EgmTestSignals_descriptor_ = file->message_type(15);
  static const int EgmTestSignals_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmTestSignals, signals_),
  };
  EgmTestSignals_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmTestSignals_descriptor_,
      EgmTestSignals::default_instance_,
      EgmTestSignals_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmTestSignals, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmTestSignals, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmTestSignals));
  EgmRobot_descriptor_ = file->message_type(16);
  static const int EgmRobot_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, feedback_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, planned_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, motorstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, mcistate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, mciconvergencemet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, testsignals_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, rapidexecstate_),
  };
  EgmRobot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmRobot_descriptor_,
      EgmRobot::default_instance_,
      EgmRobot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmRobot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmRobot));
  EgmSensor_descriptor_ = file->message_type(17);
  static const int EgmSensor_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensor, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensor, planned_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensor, speedref_),
  };
  EgmSensor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmSensor_descriptor_,
      EgmSensor::default_instance_,
      EgmSensor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmSensor));
  EgmSensorPathCorr_descriptor_ = file->message_type(18);
  static const int EgmSensorPathCorr_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensorPathCorr, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensorPathCorr, pathcorr_),
  };
  EgmSensorPathCorr_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EgmSensorPathCorr_descriptor_,
      EgmSensorPathCorr::default_instance_,
      EgmSensorPathCorr_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensorPathCorr, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EgmSensorPathCorr, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EgmSensorPathCorr));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_egm_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmHeader_descriptor_, &EgmHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmCartesian_descriptor_, &EgmCartesian::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmQuaternion_descriptor_, &EgmQuaternion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmEuler_descriptor_, &EgmEuler::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmPose_descriptor_, &EgmPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmCartesianSpeed_descriptor_, &EgmCartesianSpeed::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmJoints_descriptor_, &EgmJoints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmExternalJoints_descriptor_, &EgmExternalJoints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmPlanned_descriptor_, &EgmPlanned::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmSpeedRef_descriptor_, &EgmSpeedRef::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmPathCorr_descriptor_, &EgmPathCorr::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmFeedBack_descriptor_, &EgmFeedBack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmMotorState_descriptor_, &EgmMotorState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmMCIState_descriptor_, &EgmMCIState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmRapidCtrlExecState_descriptor_, &EgmRapidCtrlExecState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmTestSignals_descriptor_, &EgmTestSignals::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmRobot_descriptor_, &EgmRobot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmSensor_descriptor_, &EgmSensor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EgmSensorPathCorr_descriptor_, &EgmSensorPathCorr::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_egm_2eproto() {
  delete EgmHeader::default_instance_;
  delete EgmHeader_reflection_;
  delete EgmCartesian::default_instance_;
  delete EgmCartesian_reflection_;
  delete EgmQuaternion::default_instance_;
  delete EgmQuaternion_reflection_;
  delete EgmEuler::default_instance_;
  delete EgmEuler_reflection_;
  delete EgmPose::default_instance_;
  delete EgmPose_reflection_;
  delete EgmCartesianSpeed::default_instance_;
  delete EgmCartesianSpeed_reflection_;
  delete EgmJoints::default_instance_;
  delete EgmJoints_reflection_;
  delete EgmExternalJoints::default_instance_;
  delete EgmExternalJoints_reflection_;
  delete EgmPlanned::default_instance_;
  delete EgmPlanned_reflection_;
  delete EgmSpeedRef::default_instance_;
  delete EgmSpeedRef_reflection_;
  delete EgmPathCorr::default_instance_;
  delete EgmPathCorr_reflection_;
  delete EgmFeedBack::default_instance_;
  delete EgmFeedBack_reflection_;
  delete EgmMotorState::default_instance_;
  delete EgmMotorState_reflection_;
  delete EgmMCIState::default_instance_;
  delete EgmMCIState_reflection_;
  delete EgmRapidCtrlExecState::default_instance_;
  delete EgmRapidCtrlExecState_reflection_;
  delete EgmTestSignals::default_instance_;
  delete EgmTestSignals_reflection_;
  delete EgmRobot::default_instance_;
  delete EgmRobot_reflection_;
  delete EgmSensor::default_instance_;
  delete EgmSensor_reflection_;
  delete EgmSensorPathCorr::default_instance_;
  delete EgmSensorPathCorr_reflection_;
}

void protobuf_AddDesc_egm_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tegm.proto\022\007abb.egm\"\353\001\n\tEgmHeader\022\r\n\005se"
    "qno\030\001 \001(\r\022\n\n\002tm\030\002 \001(\r\022@\n\005mtype\030\003 \001(\0162\036.a"
    "bb.egm.EgmHeader.MessageType:\021MSGTYPE_UN"
    "DEFINED\"\200\001\n\013MessageType\022\025\n\021MSGTYPE_UNDEF"
    "INED\020\000\022\023\n\017MSGTYPE_COMMAND\020\001\022\020\n\014MSGTYPE_D"
    "ATA\020\002\022\026\n\022MSGTYPE_CORRECTION\020\003\022\033\n\027MSGTYPE"
    "_PATH_CORRECTION\020\004\"/\n\014EgmCartesian\022\t\n\001x\030"
    "\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"\?\n\rEgmQuater"
    "nion\022\n\n\002u0\030\001 \002(\001\022\n\n\002u1\030\002 \002(\001\022\n\n\002u2\030\003 \002(\001"
    "\022\n\n\002u3\030\004 \002(\001\"+\n\010EgmEuler\022\t\n\001x\030\001 \002(\001\022\t\n\001y"
    "\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"w\n\007EgmPose\022\"\n\003pos\030\001 \001("
    "\0132\025.abb.egm.EgmCartesian\022&\n\006orient\030\002 \001(\013"
    "2\026.abb.egm.EgmQuaternion\022 \n\005euler\030\003 \001(\0132"
    "\021.abb.egm.EgmEuler\"\"\n\021EgmCartesianSpeed\022"
    "\r\n\005value\030\001 \003(\001\"\033\n\tEgmJoints\022\016\n\006joints\030\001 "
    "\003(\001\"#\n\021EgmExternalJoints\022\016\n\006joints\030\001 \003(\001"
    "\"\201\001\n\nEgmPlanned\022\"\n\006joints\030\001 \001(\0132\022.abb.eg"
    "m.EgmJoints\022#\n\tcartesian\030\002 \001(\0132\020.abb.egm"
    ".EgmPose\022*\n\016externalJoints\030\003 \001(\0132\022.abb.e"
    "gm.EgmJoints\"\215\001\n\013EgmSpeedRef\022\"\n\006joints\030\001"
    " \001(\0132\022.abb.egm.EgmJoints\022.\n\ncartesians\030\002"
    " \001(\0132\032.abb.egm.EgmCartesianSpeed\022*\n\016exte"
    "rnalJoints\030\003 \001(\0132\022.abb.egm.EgmJoints\">\n\013"
    "EgmPathCorr\022\"\n\003pos\030\001 \002(\0132\025.abb.egm.EgmCa"
    "rtesian\022\013\n\003age\030\002 \002(\r\"\202\001\n\013EgmFeedBack\022\"\n\006"
    "joints\030\001 \001(\0132\022.abb.egm.EgmJoints\022#\n\tcart"
    "esian\030\002 \001(\0132\020.abb.egm.EgmPose\022*\n\016externa"
    "lJoints\030\003 \001(\0132\022.abb.egm.EgmJoints\"\214\001\n\rEg"
    "mMotorState\0224\n\005state\030\001 \002(\0162%.abb.egm.Egm"
    "MotorState.MotorStateType\"E\n\016MotorStateT"
    "ype\022\024\n\020MOTORS_UNDEFINED\020\000\022\r\n\tMOTORS_ON\020\001"
    "\022\016\n\nMOTORS_OFF\020\002\"\242\001\n\013EgmMCIState\022\?\n\005stat"
    "e\030\001 \002(\0162!.abb.egm.EgmMCIState.MCIStateTy"
    "pe:\rMCI_UNDEFINED\"R\n\014MCIStateType\022\021\n\rMCI"
    "_UNDEFINED\020\000\022\r\n\tMCI_ERROR\020\001\022\017\n\013MCI_STOPP"
    "ED\020\002\022\017\n\013MCI_RUNNING\020\003\"\303\001\n\025EgmRapidCtrlEx"
    "ecState\022U\n\005state\030\001 \002(\01625.abb.egm.EgmRapi"
    "dCtrlExecState.RapidCtrlExecStateType:\017R"
    "APID_UNDEFINED\"S\n\026RapidCtrlExecStateType"
    "\022\023\n\017RAPID_UNDEFINED\020\000\022\021\n\rRAPID_STOPPED\020\001"
    "\022\021\n\rRAPID_RUNNING\020\002\"!\n\016EgmTestSignals\022\017\n"
    "\007signals\030\001 \003(\001\"\321\002\n\010EgmRobot\022\"\n\006header\030\001 "
    "\001(\0132\022.abb.egm.EgmHeader\022&\n\010feedBack\030\002 \001("
    "\0132\024.abb.egm.EgmFeedBack\022$\n\007planned\030\003 \001(\013"
    "2\023.abb.egm.EgmPlanned\022*\n\nmotorState\030\004 \001("
    "\0132\026.abb.egm.EgmMotorState\022&\n\010mciState\030\005 "
    "\001(\0132\024.abb.egm.EgmMCIState\022\031\n\021mciConverge"
    "nceMet\030\006 \001(\010\022,\n\013testSignals\030\007 \001(\0132\027.abb."
    "egm.EgmTestSignals\0226\n\016rapidExecState\030\010 \001"
    "(\0132\036.abb.egm.EgmRapidCtrlExecState\"}\n\tEg"
    "mSensor\022\"\n\006header\030\001 \001(\0132\022.abb.egm.EgmHea"
    "der\022$\n\007planned\030\002 \001(\0132\023.abb.egm.EgmPlanne"
    "d\022&\n\010speedRef\030\003 \001(\0132\024.abb.egm.EgmSpeedRe"
    "f\"_\n\021EgmSensorPathCorr\022\"\n\006header\030\001 \001(\0132\022"
    ".abb.egm.EgmHeader\022&\n\010pathCorr\030\002 \001(\0132\024.a"
    "bb.egm.EgmPathCorr", 2218);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "egm.proto", &protobuf_RegisterTypes);
  EgmHeader::default_instance_ = new EgmHeader();
  EgmCartesian::default_instance_ = new EgmCartesian();
  EgmQuaternion::default_instance_ = new EgmQuaternion();
  EgmEuler::default_instance_ = new EgmEuler();
  EgmPose::default_instance_ = new EgmPose();
  EgmCartesianSpeed::default_instance_ = new EgmCartesianSpeed();
  EgmJoints::default_instance_ = new EgmJoints();
  EgmExternalJoints::default_instance_ = new EgmExternalJoints();
  EgmPlanned::default_instance_ = new EgmPlanned();
  EgmSpeedRef::default_instance_ = new EgmSpeedRef();
  EgmPathCorr::default_instance_ = new EgmPathCorr();
  EgmFeedBack::default_instance_ = new EgmFeedBack();
  EgmMotorState::default_instance_ = new EgmMotorState();
  EgmMCIState::default_instance_ = new EgmMCIState();
  EgmRapidCtrlExecState::default_instance_ = new EgmRapidCtrlExecState();
  EgmTestSignals::default_instance_ = new EgmTestSignals();
  EgmRobot::default_instance_ = new EgmRobot();
  EgmSensor::default_instance_ = new EgmSensor();
  EgmSensorPathCorr::default_instance_ = new EgmSensorPathCorr();
  EgmHeader::default_instance_->InitAsDefaultInstance();
  EgmCartesian::default_instance_->InitAsDefaultInstance();
  EgmQuaternion::default_instance_->InitAsDefaultInstance();
  EgmEuler::default_instance_->InitAsDefaultInstance();
  EgmPose::default_instance_->InitAsDefaultInstance();
  EgmCartesianSpeed::default_instance_->InitAsDefaultInstance();
  EgmJoints::default_instance_->InitAsDefaultInstance();
  EgmExternalJoints::default_instance_->InitAsDefaultInstance();
  EgmPlanned::default_instance_->InitAsDefaultInstance();
  EgmSpeedRef::default_instance_->InitAsDefaultInstance();
  EgmPathCorr::default_instance_->InitAsDefaultInstance();
  EgmFeedBack::default_instance_->InitAsDefaultInstance();
  EgmMotorState::default_instance_->InitAsDefaultInstance();
  EgmMCIState::default_instance_->InitAsDefaultInstance();
  EgmRapidCtrlExecState::default_instance_->InitAsDefaultInstance();
  EgmTestSignals::default_instance_->InitAsDefaultInstance();
  EgmRobot::default_instance_->InitAsDefaultInstance();
  EgmSensor::default_instance_->InitAsDefaultInstance();
  EgmSensorPathCorr::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_egm_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_egm_2eproto {
  StaticDescriptorInitializer_egm_2eproto() {
    protobuf_AddDesc_egm_2eproto();
  }
} static_descriptor_initializer_egm_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* EgmHeader_MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmHeader_MessageType_descriptor_;
}
bool EgmHeader_MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const EgmHeader_MessageType EgmHeader::MSGTYPE_UNDEFINED;
const EgmHeader_MessageType EgmHeader::MSGTYPE_COMMAND;
const EgmHeader_MessageType EgmHeader::MSGTYPE_DATA;
const EgmHeader_MessageType EgmHeader::MSGTYPE_CORRECTION;
const EgmHeader_MessageType EgmHeader::MSGTYPE_PATH_CORRECTION;
const EgmHeader_MessageType EgmHeader::MessageType_MIN;
const EgmHeader_MessageType EgmHeader::MessageType_MAX;
const int EgmHeader::MessageType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int EgmHeader::kSeqnoFieldNumber;
const int EgmHeader::kTmFieldNumber;
const int EgmHeader::kMtypeFieldNumber;
#endif  // !_MSC_VER

EgmHeader::EgmHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmHeader)
}

void EgmHeader::InitAsDefaultInstance() {
}

EgmHeader::EgmHeader(const EgmHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmHeader)
}

void EgmHeader::SharedCtor() {
  _cached_size_ = 0;
  seqno_ = 0u;
  tm_ = 0u;
  mtype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmHeader::~EgmHeader() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmHeader)
  SharedDtor();
}

void EgmHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmHeader_descriptor_;
}

const EgmHeader& EgmHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmHeader* EgmHeader::default_instance_ = NULL;

EgmHeader* EgmHeader::New() const {
  return new EgmHeader;
}

void EgmHeader::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EgmHeader*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(seqno_, mtype_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 seqno = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seqno_)));
          set_has_seqno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_tm;
        break;
      }

      // optional uint32 tm = 2;
      case 2: {
        if (tag == 16) {
         parse_tm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tm_)));
          set_has_tm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mtype;
        break;
      }

      // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
      case 3: {
        if (tag == 24) {
         parse_mtype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmHeader_MessageType_IsValid(value)) {
            set_mtype(static_cast< ::abb::egm::EgmHeader_MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmHeader)
  return false;
#undef DO_
}

void EgmHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmHeader)
  // optional uint32 seqno = 1;
  if (has_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->seqno(), output);
  }

  // optional uint32 tm = 2;
  if (has_tm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tm(), output);
  }

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  if (has_mtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->mtype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmHeader)
}

::google::protobuf::uint8* EgmHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmHeader)
  // optional uint32 seqno = 1;
  if (has_seqno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->seqno(), target);
  }

  // optional uint32 tm = 2;
  if (has_tm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->tm(), target);
  }

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  if (has_mtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->mtype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmHeader)
  return target;
}

int EgmHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 seqno = 1;
    if (has_seqno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seqno());
    }

    // optional uint32 tm = 2;
    if (has_tm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tm());
    }

    // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
    if (has_mtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mtype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmHeader::MergeFrom(const EgmHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seqno()) {
      set_seqno(from.seqno());
    }
    if (from.has_tm()) {
      set_tm(from.tm());
    }
    if (from.has_mtype()) {
      set_mtype(from.mtype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmHeader::CopyFrom(const EgmHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmHeader::IsInitialized() const {

  return true;
}

void EgmHeader::Swap(EgmHeader* other) {
  if (other != this) {
    std::swap(seqno_, other->seqno_);
    std::swap(tm_, other->tm_);
    std::swap(mtype_, other->mtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmHeader_descriptor_;
  metadata.reflection = EgmHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmCartesian::kXFieldNumber;
const int EgmCartesian::kYFieldNumber;
const int EgmCartesian::kZFieldNumber;
#endif  // !_MSC_VER

EgmCartesian::EgmCartesian()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmCartesian)
}

void EgmCartesian::InitAsDefaultInstance() {
}

EgmCartesian::EgmCartesian(const EgmCartesian& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesian)
}

void EgmCartesian::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmCartesian::~EgmCartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesian)
  SharedDtor();
}

void EgmCartesian::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmCartesian::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmCartesian::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmCartesian_descriptor_;
}

const EgmCartesian& EgmCartesian::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmCartesian* EgmCartesian::default_instance_ = NULL;

EgmCartesian* EgmCartesian::New() const {
  return new EgmCartesian;
}

void EgmCartesian::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EgmCartesian*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmCartesian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmCartesian)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmCartesian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmCartesian)
  return false;
#undef DO_
}

void EgmCartesian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmCartesian)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmCartesian)
}

::google::protobuf::uint8* EgmCartesian::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesian)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesian)
  return target;
}

int EgmCartesian::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // required double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // required double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmCartesian::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmCartesian* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmCartesian*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmCartesian::MergeFrom(const EgmCartesian& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmCartesian::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmCartesian::CopyFrom(const EgmCartesian& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesian::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void EgmCartesian::Swap(EgmCartesian* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmCartesian::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmCartesian_descriptor_;
  metadata.reflection = EgmCartesian_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmQuaternion::kU0FieldNumber;
const int EgmQuaternion::kU1FieldNumber;
const int EgmQuaternion::kU2FieldNumber;
const int EgmQuaternion::kU3FieldNumber;
#endif  // !_MSC_VER

EgmQuaternion::EgmQuaternion()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmQuaternion)
}

void EgmQuaternion::InitAsDefaultInstance() {
}

EgmQuaternion::EgmQuaternion(const EgmQuaternion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmQuaternion)
}

void EgmQuaternion::SharedCtor() {
  _cached_size_ = 0;
  u0_ = 0;
  u1_ = 0;
  u2_ = 0;
  u3_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmQuaternion::~EgmQuaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmQuaternion)
  SharedDtor();
}

void EgmQuaternion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmQuaternion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmQuaternion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmQuaternion_descriptor_;
}

const EgmQuaternion& EgmQuaternion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmQuaternion* EgmQuaternion::default_instance_ = NULL;

EgmQuaternion* EgmQuaternion::New() const {
  return new EgmQuaternion;
}

void EgmQuaternion::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EgmQuaternion*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(u0_, u3_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmQuaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmQuaternion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double u0 = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u0_)));
          set_has_u0();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_u1;
        break;
      }

      // required double u1 = 2;
      case 2: {
        if (tag == 17) {
         parse_u1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u1_)));
          set_has_u1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_u2;
        break;
      }

      // required double u2 = 3;
      case 3: {
        if (tag == 25) {
         parse_u2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u2_)));
          set_has_u2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_u3;
        break;
      }

      // required double u3 = 4;
      case 4: {
        if (tag == 33) {
         parse_u3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u3_)));
          set_has_u3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmQuaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmQuaternion)
  return false;
#undef DO_
}

void EgmQuaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmQuaternion)
  // required double u0 = 1;
  if (has_u0()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->u0(), output);
  }

  // required double u1 = 2;
  if (has_u1()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->u1(), output);
  }

  // required double u2 = 3;
  if (has_u2()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->u2(), output);
  }

  // required double u3 = 4;
  if (has_u3()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->u3(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmQuaternion)
}

::google::protobuf::uint8* EgmQuaternion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmQuaternion)
  // required double u0 = 1;
  if (has_u0()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->u0(), target);
  }

  // required double u1 = 2;
  if (has_u1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->u1(), target);
  }

  // required double u2 = 3;
  if (has_u2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->u2(), target);
  }

  // required double u3 = 4;
  if (has_u3()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->u3(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmQuaternion)
  return target;
}

int EgmQuaternion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double u0 = 1;
    if (has_u0()) {
      total_size += 1 + 8;
    }

    // required double u1 = 2;
    if (has_u1()) {
      total_size += 1 + 8;
    }

    // required double u2 = 3;
    if (has_u2()) {
      total_size += 1 + 8;
    }

    // required double u3 = 4;
    if (has_u3()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmQuaternion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmQuaternion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmQuaternion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmQuaternion::MergeFrom(const EgmQuaternion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_u0()) {
      set_u0(from.u0());
    }
    if (from.has_u1()) {
      set_u1(from.u1());
    }
    if (from.has_u2()) {
      set_u2(from.u2());
    }
    if (from.has_u3()) {
      set_u3(from.u3());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmQuaternion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmQuaternion::CopyFrom(const EgmQuaternion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmQuaternion::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void EgmQuaternion::Swap(EgmQuaternion* other) {
  if (other != this) {
    std::swap(u0_, other->u0_);
    std::swap(u1_, other->u1_);
    std::swap(u2_, other->u2_);
    std::swap(u3_, other->u3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmQuaternion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmQuaternion_descriptor_;
  metadata.reflection = EgmQuaternion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmEuler::kXFieldNumber;
const int EgmEuler::kYFieldNumber;
const int EgmEuler::kZFieldNumber;
#endif  // !_MSC_VER

EgmEuler::EgmEuler()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmEuler)
}

void EgmEuler::InitAsDefaultInstance() {
}

EgmEuler::EgmEuler(const EgmEuler& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmEuler)
}

void EgmEuler::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmEuler::~EgmEuler() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmEuler)
  SharedDtor();
}

void EgmEuler::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmEuler::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmEuler::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmEuler_descriptor_;
}

const EgmEuler& EgmEuler::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmEuler* EgmEuler::default_instance_ = NULL;

EgmEuler* EgmEuler::New() const {
  return new EgmEuler;
}

void EgmEuler::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EgmEuler*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmEuler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmEuler)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmEuler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmEuler)
  return false;
#undef DO_
}

void EgmEuler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmEuler)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmEuler)
}

::google::protobuf::uint8* EgmEuler::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmEuler)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmEuler)
  return target;
}

int EgmEuler::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // required double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // required double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmEuler::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmEuler* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmEuler*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmEuler::MergeFrom(const EgmEuler& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmEuler::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmEuler::CopyFrom(const EgmEuler& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmEuler::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void EgmEuler::Swap(EgmEuler* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmEuler::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmEuler_descriptor_;
  metadata.reflection = EgmEuler_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmPose::kPosFieldNumber;
const int EgmPose::kOrientFieldNumber;
const int EgmPose::kEulerFieldNumber;
#endif  // !_MSC_VER

EgmPose::EgmPose()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmPose)
}

void EgmPose::InitAsDefaultInstance() {
  pos_ = const_cast< ::abb::egm::EgmCartesian*>(&::abb::egm::EgmCartesian::default_instance());
  orient_ = const_cast< ::abb::egm::EgmQuaternion*>(&::abb::egm::EgmQuaternion::default_instance());
  euler_ = const_cast< ::abb::egm::EgmEuler*>(&::abb::egm::EgmEuler::default_instance());
}

EgmPose::EgmPose(const EgmPose& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPose)
}

void EgmPose::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  orient_ = NULL;
  euler_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmPose::~EgmPose() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPose)
  SharedDtor();
}

void EgmPose::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete orient_;
    delete euler_;
  }
}

void EgmPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmPose_descriptor_;
}

const EgmPose& EgmPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmPose* EgmPose::default_instance_ = NULL;

EgmPose* EgmPose::New() const {
  return new EgmPose;
}

void EgmPose::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_pos()) {
      if (pos_ != NULL) pos_->::abb::egm::EgmCartesian::Clear();
    }
    if (has_orient()) {
      if (orient_ != NULL) orient_->::abb::egm::EgmQuaternion::Clear();
    }
    if (has_euler()) {
      if (euler_ != NULL) euler_->::abb::egm::EgmEuler::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmCartesian pos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orient;
        break;
      }

      // optional .abb.egm.EgmQuaternion orient = 2;
      case 2: {
        if (tag == 18) {
         parse_orient:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orient()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_euler;
        break;
      }

      // optional .abb.egm.EgmEuler euler = 3;
      case 3: {
        if (tag == 26) {
         parse_euler:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_euler()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmPose)
  return false;
#undef DO_
}

void EgmPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmPose)
  // optional .abb.egm.EgmCartesian pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pos(), output);
  }

  // optional .abb.egm.EgmQuaternion orient = 2;
  if (has_orient()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->orient(), output);
  }

  // optional .abb.egm.EgmEuler euler = 3;
  if (has_euler()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->euler(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmPose)
}

::google::protobuf::uint8* EgmPose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPose)
  // optional .abb.egm.EgmCartesian pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pos(), target);
  }

  // optional .abb.egm.EgmQuaternion orient = 2;
  if (has_orient()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->orient(), target);
  }

  // optional .abb.egm.EgmEuler euler = 3;
  if (has_euler()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->euler(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPose)
  return target;
}

int EgmPose::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmCartesian pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

    // optional .abb.egm.EgmQuaternion orient = 2;
    if (has_orient()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->orient());
    }

    // optional .abb.egm.EgmEuler euler = 3;
    if (has_euler()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->euler());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmPose::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmPose* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmPose*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmPose::MergeFrom(const EgmPose& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(from.pos());
    }
    if (from.has_orient()) {
      mutable_orient()->::abb::egm::EgmQuaternion::MergeFrom(from.orient());
    }
    if (from.has_euler()) {
      mutable_euler()->::abb::egm::EgmEuler::MergeFrom(from.euler());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmPose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPose::CopyFrom(const EgmPose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPose::IsInitialized() const {

  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  if (has_orient()) {
    if (!this->orient().IsInitialized()) return false;
  }
  if (has_euler()) {
    if (!this->euler().IsInitialized()) return false;
  }
  return true;
}

void EgmPose::Swap(EgmPose* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(orient_, other->orient_);
    std::swap(euler_, other->euler_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmPose_descriptor_;
  metadata.reflection = EgmPose_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmCartesianSpeed::kValueFieldNumber;
#endif  // !_MSC_VER

EgmCartesianSpeed::EgmCartesianSpeed()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmCartesianSpeed)
}

void EgmCartesianSpeed::InitAsDefaultInstance() {
}

EgmCartesianSpeed::EgmCartesianSpeed(const EgmCartesianSpeed& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesianSpeed)
}

void EgmCartesianSpeed::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmCartesianSpeed::~EgmCartesianSpeed() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesianSpeed)
  SharedDtor();
}

void EgmCartesianSpeed::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmCartesianSpeed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmCartesianSpeed::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmCartesianSpeed_descriptor_;
}

const EgmCartesianSpeed& EgmCartesianSpeed::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmCartesianSpeed* EgmCartesianSpeed::default_instance_ = NULL;

EgmCartesianSpeed* EgmCartesianSpeed::New() const {
  return new EgmCartesianSpeed;
}

void EgmCartesianSpeed::Clear() {
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmCartesianSpeed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmCartesianSpeed)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double value = 1;
      case 1: {
        if (tag == 9) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9, input, this->mutable_value())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_value())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(9)) goto parse_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmCartesianSpeed)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmCartesianSpeed)
  return false;
#undef DO_
}

void EgmCartesianSpeed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmCartesianSpeed)
  // repeated double value = 1;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->value(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmCartesianSpeed)
}

::google::protobuf::uint8* EgmCartesianSpeed::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesianSpeed)
  // repeated double value = 1;
  for (int i = 0; i < this->value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(1, this->value(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesianSpeed)
  return target;
}

int EgmCartesianSpeed::ByteSize() const {
  int total_size = 0;

  // repeated double value = 1;
  {
    int data_size = 0;
    data_size = 8 * this->value_size();
    total_size += 1 * this->value_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmCartesianSpeed::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmCartesianSpeed* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmCartesianSpeed*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmCartesianSpeed::MergeFrom(const EgmCartesianSpeed& from) {
  GOOGLE_CHECK_NE(&from, this);
  value_.MergeFrom(from.value_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmCartesianSpeed::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmCartesianSpeed::CopyFrom(const EgmCartesianSpeed& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesianSpeed::IsInitialized() const {

  return true;
}

void EgmCartesianSpeed::Swap(EgmCartesianSpeed* other) {
  if (other != this) {
    value_.Swap(&other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmCartesianSpeed::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmCartesianSpeed_descriptor_;
  metadata.reflection = EgmCartesianSpeed_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmJoints::kJointsFieldNumber;
#endif  // !_MSC_VER

EgmJoints::EgmJoints()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmJoints)
}

void EgmJoints::InitAsDefaultInstance() {
}

EgmJoints::EgmJoints(const EgmJoints& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmJoints)
}

void EgmJoints::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmJoints::~EgmJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmJoints)
  SharedDtor();
}

void EgmJoints::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmJoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmJoints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmJoints_descriptor_;
}

const EgmJoints& EgmJoints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmJoints* EgmJoints::default_instance_ = NULL;

EgmJoints* EgmJoints::New() const {
  return new EgmJoints;
}

void EgmJoints::Clear() {
  joints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmJoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmJoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double joints = 1;
      case 1: {
        if (tag == 9) {
         parse_joints:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9, input, this->mutable_joints())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_joints())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(9)) goto parse_joints;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmJoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmJoints)
  return false;
#undef DO_
}

void EgmJoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmJoints)
  // repeated double joints = 1;
  for (int i = 0; i < this->joints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->joints(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmJoints)
}

::google::protobuf::uint8* EgmJoints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmJoints)
  // repeated double joints = 1;
  for (int i = 0; i < this->joints_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(1, this->joints(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmJoints)
  return target;
}

int EgmJoints::ByteSize() const {
  int total_size = 0;

  // repeated double joints = 1;
  {
    int data_size = 0;
    data_size = 8 * this->joints_size();
    total_size += 1 * this->joints_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmJoints::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmJoints* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmJoints*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmJoints::MergeFrom(const EgmJoints& from) {
  GOOGLE_CHECK_NE(&from, this);
  joints_.MergeFrom(from.joints_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmJoints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmJoints::CopyFrom(const EgmJoints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmJoints::IsInitialized() const {

  return true;
}

void EgmJoints::Swap(EgmJoints* other) {
  if (other != this) {
    joints_.Swap(&other->joints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmJoints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmJoints_descriptor_;
  metadata.reflection = EgmJoints_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmExternalJoints::kJointsFieldNumber;
#endif  // !_MSC_VER

EgmExternalJoints::EgmExternalJoints()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmExternalJoints)
}

void EgmExternalJoints::InitAsDefaultInstance() {
}

EgmExternalJoints::EgmExternalJoints(const EgmExternalJoints& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmExternalJoints)
}

void EgmExternalJoints::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmExternalJoints::~EgmExternalJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmExternalJoints)
  SharedDtor();
}

void EgmExternalJoints::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmExternalJoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmExternalJoints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmExternalJoints_descriptor_;
}

const EgmExternalJoints& EgmExternalJoints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmExternalJoints* EgmExternalJoints::default_instance_ = NULL;

EgmExternalJoints* EgmExternalJoints::New() const {
  return new EgmExternalJoints;
}

void EgmExternalJoints::Clear() {
  joints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmExternalJoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmExternalJoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double joints = 1;
      case 1: {
        if (tag == 9) {
         parse_joints:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9, input, this->mutable_joints())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_joints())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(9)) goto parse_joints;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmExternalJoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmExternalJoints)
  return false;
#undef DO_
}

void EgmExternalJoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmExternalJoints)
  // repeated double joints = 1;
  for (int i = 0; i < this->joints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->joints(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmExternalJoints)
}

::google::protobuf::uint8* EgmExternalJoints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmExternalJoints)
  // repeated double joints = 1;
  for (int i = 0; i < this->joints_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(1, this->joints(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmExternalJoints)
  return target;
}

int EgmExternalJoints::ByteSize() const {
  int total_size = 0;

  // repeated double joints = 1;
  {
    int data_size = 0;
    data_size = 8 * this->joints_size();
    total_size += 1 * this->joints_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmExternalJoints::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmExternalJoints* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmExternalJoints*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmExternalJoints::MergeFrom(const EgmExternalJoints& from) {
  GOOGLE_CHECK_NE(&from, this);
  joints_.MergeFrom(from.joints_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmExternalJoints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmExternalJoints::CopyFrom(const EgmExternalJoints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmExternalJoints::IsInitialized() const {

  return true;
}

void EgmExternalJoints::Swap(EgmExternalJoints* other) {
  if (other != this) {
    joints_.Swap(&other->joints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmExternalJoints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmExternalJoints_descriptor_;
  metadata.reflection = EgmExternalJoints_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmPlanned::kJointsFieldNumber;
const int EgmPlanned::kCartesianFieldNumber;
const int EgmPlanned::kExternalJointsFieldNumber;
#endif  // !_MSC_VER

EgmPlanned::EgmPlanned()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmPlanned)
}

void EgmPlanned::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::EgmJoints*>(&::abb::egm::EgmJoints::default_instance());
  cartesian_ = const_cast< ::abb::egm::EgmPose*>(&::abb::egm::EgmPose::default_instance());
  externaljoints_ = const_cast< ::abb::egm::EgmJoints*>(&::abb::egm::EgmJoints::default_instance());
}

EgmPlanned::EgmPlanned(const EgmPlanned& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPlanned)
}

void EgmPlanned::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesian_ = NULL;
  externaljoints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmPlanned::~EgmPlanned() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPlanned)
  SharedDtor();
}

void EgmPlanned::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesian_;
    delete externaljoints_;
  }
}

void EgmPlanned::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmPlanned::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmPlanned_descriptor_;
}

const EgmPlanned& EgmPlanned::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmPlanned* EgmPlanned::default_instance_ = NULL;

EgmPlanned* EgmPlanned::New() const {
  return new EgmPlanned;
}

void EgmPlanned::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::EgmJoints::Clear();
    }
    if (has_cartesian()) {
      if (cartesian_ != NULL) cartesian_->::abb::egm::EgmPose::Clear();
    }
    if (has_externaljoints()) {
      if (externaljoints_ != NULL) externaljoints_->::abb::egm::EgmJoints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmPlanned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmPlanned)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesian;
        break;
      }

      // optional .abb.egm.EgmPose cartesian = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_externalJoints;
        break;
      }

      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3: {
        if (tag == 26) {
         parse_externalJoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_externaljoints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmPlanned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmPlanned)
  return false;
#undef DO_
}

void EgmPlanned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmPlanned)
  // optional .abb.egm.EgmJoints joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (has_cartesian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesian(), output);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (has_externaljoints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->externaljoints(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmPlanned)
}

::google::protobuf::uint8* EgmPlanned::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPlanned)
  // optional .abb.egm.EgmJoints joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (has_cartesian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesian(), target);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (has_externaljoints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->externaljoints(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPlanned)
  return target;
}

int EgmPlanned::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesian());
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (has_externaljoints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->externaljoints());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmPlanned::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmPlanned* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmPlanned*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmPlanned::MergeFrom(const EgmPlanned& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from.joints());
    }
    if (from.has_cartesian()) {
      mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(from.cartesian());
    }
    if (from.has_externaljoints()) {
      mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from.externaljoints());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmPlanned::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPlanned::CopyFrom(const EgmPlanned& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPlanned::IsInitialized() const {

  if (has_cartesian()) {
    if (!this->cartesian().IsInitialized()) return false;
  }
  return true;
}

void EgmPlanned::Swap(EgmPlanned* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesian_, other->cartesian_);
    std::swap(externaljoints_, other->externaljoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmPlanned::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmPlanned_descriptor_;
  metadata.reflection = EgmPlanned_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmSpeedRef::kJointsFieldNumber;
const int EgmSpeedRef::kCartesiansFieldNumber;
const int EgmSpeedRef::kExternalJointsFieldNumber;
#endif  // !_MSC_VER

EgmSpeedRef::EgmSpeedRef()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmSpeedRef)
}

void EgmSpeedRef::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::EgmJoints*>(&::abb::egm::EgmJoints::default_instance());
  cartesians_ = const_cast< ::abb::egm::EgmCartesianSpeed*>(&::abb::egm::EgmCartesianSpeed::default_instance());
  externaljoints_ = const_cast< ::abb::egm::EgmJoints*>(&::abb::egm::EgmJoints::default_instance());
}

EgmSpeedRef::EgmSpeedRef(const EgmSpeedRef& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSpeedRef)
}

void EgmSpeedRef::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesians_ = NULL;
  externaljoints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmSpeedRef::~EgmSpeedRef() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSpeedRef)
  SharedDtor();
}

void EgmSpeedRef::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesians_;
    delete externaljoints_;
  }
}

void EgmSpeedRef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmSpeedRef::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmSpeedRef_descriptor_;
}

const EgmSpeedRef& EgmSpeedRef::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmSpeedRef* EgmSpeedRef::default_instance_ = NULL;

EgmSpeedRef* EgmSpeedRef::New() const {
  return new EgmSpeedRef;
}

void EgmSpeedRef::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::EgmJoints::Clear();
    }
    if (has_cartesians()) {
      if (cartesians_ != NULL) cartesians_->::abb::egm::EgmCartesianSpeed::Clear();
    }
    if (has_externaljoints()) {
      if (externaljoints_ != NULL) externaljoints_->::abb::egm::EgmJoints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmSpeedRef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmSpeedRef)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesians;
        break;
      }

      // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesians:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesians()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_externalJoints;
        break;
      }

      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3: {
        if (tag == 26) {
         parse_externalJoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_externaljoints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmSpeedRef)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmSpeedRef)
  return false;
#undef DO_
}

void EgmSpeedRef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmSpeedRef)
  // optional .abb.egm.EgmJoints joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  if (has_cartesians()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesians(), output);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (has_externaljoints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->externaljoints(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmSpeedRef)
}

::google::protobuf::uint8* EgmSpeedRef::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSpeedRef)
  // optional .abb.egm.EgmJoints joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  if (has_cartesians()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesians(), target);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (has_externaljoints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->externaljoints(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSpeedRef)
  return target;
}

int EgmSpeedRef::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
    if (has_cartesians()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesians());
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (has_externaljoints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->externaljoints());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmSpeedRef::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmSpeedRef* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmSpeedRef*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmSpeedRef::MergeFrom(const EgmSpeedRef& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from.joints());
    }
    if (from.has_cartesians()) {
      mutable_cartesians()->::abb::egm::EgmCartesianSpeed::MergeFrom(from.cartesians());
    }
    if (from.has_externaljoints()) {
      mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from.externaljoints());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmSpeedRef::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSpeedRef::CopyFrom(const EgmSpeedRef& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSpeedRef::IsInitialized() const {

  return true;
}

void EgmSpeedRef::Swap(EgmSpeedRef* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesians_, other->cartesians_);
    std::swap(externaljoints_, other->externaljoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmSpeedRef::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmSpeedRef_descriptor_;
  metadata.reflection = EgmSpeedRef_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmPathCorr::kPosFieldNumber;
const int EgmPathCorr::kAgeFieldNumber;
#endif  // !_MSC_VER

EgmPathCorr::EgmPathCorr()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmPathCorr)
}

void EgmPathCorr::InitAsDefaultInstance() {
  pos_ = const_cast< ::abb::egm::EgmCartesian*>(&::abb::egm::EgmCartesian::default_instance());
}

EgmPathCorr::EgmPathCorr(const EgmPathCorr& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPathCorr)
}

void EgmPathCorr::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  age_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmPathCorr::~EgmPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPathCorr)
  SharedDtor();
}

void EgmPathCorr::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
  }
}

void EgmPathCorr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmPathCorr::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmPathCorr_descriptor_;
}

const EgmPathCorr& EgmPathCorr::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmPathCorr* EgmPathCorr::default_instance_ = NULL;

EgmPathCorr* EgmPathCorr::New() const {
  return new EgmPathCorr;
}

void EgmPathCorr::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_pos()) {
      if (pos_ != NULL) pos_->::abb::egm::EgmCartesian::Clear();
    }
    age_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmPathCorr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmPathCorr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmCartesian pos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_age;
        break;
      }

      // required uint32 age = 2;
      case 2: {
        if (tag == 16) {
         parse_age:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &age_)));
          set_has_age();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmPathCorr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmPathCorr)
  return false;
#undef DO_
}

void EgmPathCorr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmPathCorr)
  // required .abb.egm.EgmCartesian pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pos(), output);
  }

  // required uint32 age = 2;
  if (has_age()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->age(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmPathCorr)
}

::google::protobuf::uint8* EgmPathCorr::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPathCorr)
  // required .abb.egm.EgmCartesian pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pos(), target);
  }

  // required uint32 age = 2;
  if (has_age()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->age(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPathCorr)
  return target;
}

int EgmPathCorr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .abb.egm.EgmCartesian pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

    // required uint32 age = 2;
    if (has_age()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->age());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmPathCorr::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmPathCorr* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmPathCorr*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmPathCorr::MergeFrom(const EgmPathCorr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(from.pos());
    }
    if (from.has_age()) {
      set_age(from.age());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmPathCorr::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPathCorr::CopyFrom(const EgmPathCorr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPathCorr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  return true;
}

void EgmPathCorr::Swap(EgmPathCorr* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(age_, other->age_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmPathCorr::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmPathCorr_descriptor_;
  metadata.reflection = EgmPathCorr_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmFeedBack::kJointsFieldNumber;
const int EgmFeedBack::kCartesianFieldNumber;
const int EgmFeedBack::kExternalJointsFieldNumber;
#endif  // !_MSC_VER

EgmFeedBack::EgmFeedBack()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmFeedBack)
}

void EgmFeedBack::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::EgmJoints*>(&::abb::egm::EgmJoints::default_instance());
  cartesian_ = const_cast< ::abb::egm::EgmPose*>(&::abb::egm::EgmPose::default_instance());
  externaljoints_ = const_cast< ::abb::egm::EgmJoints*>(&::abb::egm::EgmJoints::default_instance());
}

EgmFeedBack::EgmFeedBack(const EgmFeedBack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmFeedBack)
}

void EgmFeedBack::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesian_ = NULL;
  externaljoints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmFeedBack::~EgmFeedBack() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmFeedBack)
  SharedDtor();
}

void EgmFeedBack::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesian_;
    delete externaljoints_;
  }
}

void EgmFeedBack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmFeedBack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmFeedBack_descriptor_;
}

const EgmFeedBack& EgmFeedBack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmFeedBack* EgmFeedBack::default_instance_ = NULL;

EgmFeedBack* EgmFeedBack::New() const {
  return new EgmFeedBack;
}

void EgmFeedBack::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::EgmJoints::Clear();
    }
    if (has_cartesian()) {
      if (cartesian_ != NULL) cartesian_->::abb::egm::EgmPose::Clear();
    }
    if (has_externaljoints()) {
      if (externaljoints_ != NULL) externaljoints_->::abb::egm::EgmJoints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmFeedBack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmFeedBack)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesian;
        break;
      }

      // optional .abb.egm.EgmPose cartesian = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_externalJoints;
        break;
      }

      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3: {
        if (tag == 26) {
         parse_externalJoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_externaljoints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmFeedBack)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmFeedBack)
  return false;
#undef DO_
}

void EgmFeedBack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmFeedBack)
  // optional .abb.egm.EgmJoints joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (has_cartesian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesian(), output);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (has_externaljoints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->externaljoints(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmFeedBack)
}

::google::protobuf::uint8* EgmFeedBack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmFeedBack)
  // optional .abb.egm.EgmJoints joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (has_cartesian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesian(), target);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (has_externaljoints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->externaljoints(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmFeedBack)
  return target;
}

int EgmFeedBack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesian());
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (has_externaljoints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->externaljoints());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmFeedBack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmFeedBack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmFeedBack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmFeedBack::MergeFrom(const EgmFeedBack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from.joints());
    }
    if (from.has_cartesian()) {
      mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(from.cartesian());
    }
    if (from.has_externaljoints()) {
      mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from.externaljoints());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmFeedBack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmFeedBack::CopyFrom(const EgmFeedBack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmFeedBack::IsInitialized() const {

  if (has_cartesian()) {
    if (!this->cartesian().IsInitialized()) return false;
  }
  return true;
}

void EgmFeedBack::Swap(EgmFeedBack* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesian_, other->cartesian_);
    std::swap(externaljoints_, other->externaljoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmFeedBack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmFeedBack_descriptor_;
  metadata.reflection = EgmFeedBack_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* EgmMotorState_MotorStateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmMotorState_MotorStateType_descriptor_;
}
bool EgmMotorState_MotorStateType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const EgmMotorState_MotorStateType EgmMotorState::MOTORS_UNDEFINED;
const EgmMotorState_MotorStateType EgmMotorState::MOTORS_ON;
const EgmMotorState_MotorStateType EgmMotorState::MOTORS_OFF;
const EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MIN;
const EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MAX;
const int EgmMotorState::MotorStateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int EgmMotorState::kStateFieldNumber;
#endif  // !_MSC_VER

EgmMotorState::EgmMotorState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmMotorState)
}

void EgmMotorState::InitAsDefaultInstance() {
}

EgmMotorState::EgmMotorState(const EgmMotorState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMotorState)
}

void EgmMotorState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmMotorState::~EgmMotorState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMotorState)
  SharedDtor();
}

void EgmMotorState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmMotorState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmMotorState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmMotorState_descriptor_;
}

const EgmMotorState& EgmMotorState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmMotorState* EgmMotorState::default_instance_ = NULL;

EgmMotorState* EgmMotorState::New() const {
  return new EgmMotorState;
}

void EgmMotorState::Clear() {
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmMotorState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmMotorState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmMotorState.MotorStateType state = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmMotorState_MotorStateType_IsValid(value)) {
            set_state(static_cast< ::abb::egm::EgmMotorState_MotorStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmMotorState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmMotorState)
  return false;
#undef DO_
}

void EgmMotorState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmMotorState)
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmMotorState)
}

::google::protobuf::uint8* EgmMotorState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMotorState)
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMotorState)
  return target;
}

int EgmMotorState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .abb.egm.EgmMotorState.MotorStateType state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmMotorState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmMotorState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmMotorState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmMotorState::MergeFrom(const EgmMotorState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmMotorState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMotorState::CopyFrom(const EgmMotorState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMotorState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EgmMotorState::Swap(EgmMotorState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmMotorState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmMotorState_descriptor_;
  metadata.reflection = EgmMotorState_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* EgmMCIState_MCIStateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmMCIState_MCIStateType_descriptor_;
}
bool EgmMCIState_MCIStateType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const EgmMCIState_MCIStateType EgmMCIState::MCI_UNDEFINED;
const EgmMCIState_MCIStateType EgmMCIState::MCI_ERROR;
const EgmMCIState_MCIStateType EgmMCIState::MCI_STOPPED;
const EgmMCIState_MCIStateType EgmMCIState::MCI_RUNNING;
const EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MIN;
const EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MAX;
const int EgmMCIState::MCIStateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int EgmMCIState::kStateFieldNumber;
#endif  // !_MSC_VER

EgmMCIState::EgmMCIState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmMCIState)
}

void EgmMCIState::InitAsDefaultInstance() {
}

EgmMCIState::EgmMCIState(const EgmMCIState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMCIState)
}

void EgmMCIState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmMCIState::~EgmMCIState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMCIState)
  SharedDtor();
}

void EgmMCIState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmMCIState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmMCIState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmMCIState_descriptor_;
}

const EgmMCIState& EgmMCIState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmMCIState* EgmMCIState::default_instance_ = NULL;

EgmMCIState* EgmMCIState::New() const {
  return new EgmMCIState;
}

void EgmMCIState::Clear() {
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmMCIState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmMCIState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmMCIState_MCIStateType_IsValid(value)) {
            set_state(static_cast< ::abb::egm::EgmMCIState_MCIStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmMCIState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmMCIState)
  return false;
#undef DO_
}

void EgmMCIState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmMCIState)
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmMCIState)
}

::google::protobuf::uint8* EgmMCIState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMCIState)
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMCIState)
  return target;
}

int EgmMCIState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmMCIState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmMCIState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmMCIState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmMCIState::MergeFrom(const EgmMCIState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmMCIState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMCIState::CopyFrom(const EgmMCIState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMCIState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EgmMCIState::Swap(EgmMCIState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmMCIState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmMCIState_descriptor_;
  metadata.reflection = EgmMCIState_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor_;
}
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_UNDEFINED;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_STOPPED;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_RUNNING;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MIN;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MAX;
const int EgmRapidCtrlExecState::RapidCtrlExecStateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int EgmRapidCtrlExecState::kStateFieldNumber;
#endif  // !_MSC_VER

EgmRapidCtrlExecState::EgmRapidCtrlExecState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmRapidCtrlExecState)
}

void EgmRapidCtrlExecState::InitAsDefaultInstance() {
}

EgmRapidCtrlExecState::EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRapidCtrlExecState)
}

void EgmRapidCtrlExecState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmRapidCtrlExecState::~EgmRapidCtrlExecState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRapidCtrlExecState)
  SharedDtor();
}

void EgmRapidCtrlExecState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmRapidCtrlExecState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmRapidCtrlExecState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmRapidCtrlExecState_descriptor_;
}

const EgmRapidCtrlExecState& EgmRapidCtrlExecState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmRapidCtrlExecState* EgmRapidCtrlExecState::default_instance_ = NULL;

EgmRapidCtrlExecState* EgmRapidCtrlExecState::New() const {
  return new EgmRapidCtrlExecState;
}

void EgmRapidCtrlExecState::Clear() {
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmRapidCtrlExecState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmRapidCtrlExecState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value)) {
            set_state(static_cast< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmRapidCtrlExecState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmRapidCtrlExecState)
  return false;
#undef DO_
}

void EgmRapidCtrlExecState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmRapidCtrlExecState)
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmRapidCtrlExecState)
}

::google::protobuf::uint8* EgmRapidCtrlExecState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRapidCtrlExecState)
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRapidCtrlExecState)
  return target;
}

int EgmRapidCtrlExecState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmRapidCtrlExecState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmRapidCtrlExecState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmRapidCtrlExecState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmRapidCtrlExecState::MergeFrom(const EgmRapidCtrlExecState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmRapidCtrlExecState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmRapidCtrlExecState::CopyFrom(const EgmRapidCtrlExecState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRapidCtrlExecState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EgmRapidCtrlExecState::Swap(EgmRapidCtrlExecState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmRapidCtrlExecState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmRapidCtrlExecState_descriptor_;
  metadata.reflection = EgmRapidCtrlExecState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmTestSignals::kSignalsFieldNumber;
#endif  // !_MSC_VER

EgmTestSignals::EgmTestSignals()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmTestSignals)
}

void EgmTestSignals::InitAsDefaultInstance() {
}

EgmTestSignals::EgmTestSignals(const EgmTestSignals& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmTestSignals)
}

void EgmTestSignals::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmTestSignals::~EgmTestSignals() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmTestSignals)
  SharedDtor();
}

void EgmTestSignals::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EgmTestSignals::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmTestSignals::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmTestSignals_descriptor_;
}

const EgmTestSignals& EgmTestSignals::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmTestSignals* EgmTestSignals::default_instance_ = NULL;

EgmTestSignals* EgmTestSignals::New() const {
  return new EgmTestSignals;
}

void EgmTestSignals::Clear() {
  signals_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmTestSignals::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmTestSignals)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double signals = 1;
      case 1: {
        if (tag == 9) {
         parse_signals:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9, input, this->mutable_signals())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_signals())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(9)) goto parse_signals;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmTestSignals)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmTestSignals)
  return false;
#undef DO_
}

void EgmTestSignals::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmTestSignals)
  // repeated double signals = 1;
  for (int i = 0; i < this->signals_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->signals(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmTestSignals)
}

::google::protobuf::uint8* EgmTestSignals::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmTestSignals)
  // repeated double signals = 1;
  for (int i = 0; i < this->signals_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(1, this->signals(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmTestSignals)
  return target;
}

int EgmTestSignals::ByteSize() const {
  int total_size = 0;

  // repeated double signals = 1;
  {
    int data_size = 0;
    data_size = 8 * this->signals_size();
    total_size += 1 * this->signals_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmTestSignals::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmTestSignals* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmTestSignals*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmTestSignals::MergeFrom(const EgmTestSignals& from) {
  GOOGLE_CHECK_NE(&from, this);
  signals_.MergeFrom(from.signals_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmTestSignals::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmTestSignals::CopyFrom(const EgmTestSignals& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmTestSignals::IsInitialized() const {

  return true;
}

void EgmTestSignals::Swap(EgmTestSignals* other) {
  if (other != this) {
    signals_.Swap(&other->signals_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmTestSignals::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmTestSignals_descriptor_;
  metadata.reflection = EgmTestSignals_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmRobot::kHeaderFieldNumber;
const int EgmRobot::kFeedBackFieldNumber;
const int EgmRobot::kPlannedFieldNumber;
const int EgmRobot::kMotorStateFieldNumber;
const int EgmRobot::kMciStateFieldNumber;
const int EgmRobot::kMciConvergenceMetFieldNumber;
const int EgmRobot::kTestSignalsFieldNumber;
const int EgmRobot::kRapidExecStateFieldNumber;
#endif  // !_MSC_VER

EgmRobot::EgmRobot()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmRobot)
}

void EgmRobot::InitAsDefaultInstance() {
  header_ = const_cast< ::abb::egm::EgmHeader*>(&::abb::egm::EgmHeader::default_instance());
  feedback_ = const_cast< ::abb::egm::EgmFeedBack*>(&::abb::egm::EgmFeedBack::default_instance());
  planned_ = const_cast< ::abb::egm::EgmPlanned*>(&::abb::egm::EgmPlanned::default_instance());
  motorstate_ = const_cast< ::abb::egm::EgmMotorState*>(&::abb::egm::EgmMotorState::default_instance());
  mcistate_ = const_cast< ::abb::egm::EgmMCIState*>(&::abb::egm::EgmMCIState::default_instance());
  testsignals_ = const_cast< ::abb::egm::EgmTestSignals*>(&::abb::egm::EgmTestSignals::default_instance());
  rapidexecstate_ = const_cast< ::abb::egm::EgmRapidCtrlExecState*>(&::abb::egm::EgmRapidCtrlExecState::default_instance());
}

EgmRobot::EgmRobot(const EgmRobot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRobot)
}

void EgmRobot::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  feedback_ = NULL;
  planned_ = NULL;
  motorstate_ = NULL;
  mcistate_ = NULL;
  mciconvergencemet_ = false;
  testsignals_ = NULL;
  rapidexecstate_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmRobot::~EgmRobot() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRobot)
  SharedDtor();
}

void EgmRobot::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete feedback_;
    delete planned_;
    delete motorstate_;
    delete mcistate_;
    delete testsignals_;
    delete rapidexecstate_;
  }
}

void EgmRobot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmRobot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmRobot_descriptor_;
}

const EgmRobot& EgmRobot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmRobot* EgmRobot::default_instance_ = NULL;

EgmRobot* EgmRobot::New() const {
  return new EgmRobot;
}

void EgmRobot::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_header()) {
      if (header_ != NULL) header_->::abb::egm::EgmHeader::Clear();
    }
    if (has_feedback()) {
      if (feedback_ != NULL) feedback_->::abb::egm::EgmFeedBack::Clear();
    }
    if (has_planned()) {
      if (planned_ != NULL) planned_->::abb::egm::EgmPlanned::Clear();
    }
    if (has_motorstate()) {
      if (motorstate_ != NULL) motorstate_->::abb::egm::EgmMotorState::Clear();
    }
    if (has_mcistate()) {
      if (mcistate_ != NULL) mcistate_->::abb::egm::EgmMCIState::Clear();
    }
    mciconvergencemet_ = false;
    if (has_testsignals()) {
      if (testsignals_ != NULL) testsignals_->::abb::egm::EgmTestSignals::Clear();
    }
    if (has_rapidexecstate()) {
      if (rapidexecstate_ != NULL) rapidexecstate_->::abb::egm::EgmRapidCtrlExecState::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmRobot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmRobot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_feedBack;
        break;
      }

      // optional .abb.egm.EgmFeedBack feedBack = 2;
      case 2: {
        if (tag == 18) {
         parse_feedBack:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_feedback()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_planned;
        break;
      }

      // optional .abb.egm.EgmPlanned planned = 3;
      case 3: {
        if (tag == 26) {
         parse_planned:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_motorState;
        break;
      }

      // optional .abb.egm.EgmMotorState motorState = 4;
      case 4: {
        if (tag == 34) {
         parse_motorState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_motorstate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mciState;
        break;
      }

      // optional .abb.egm.EgmMCIState mciState = 5;
      case 5: {
        if (tag == 42) {
         parse_mciState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mcistate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_mciConvergenceMet;
        break;
      }

      // optional bool mciConvergenceMet = 6;
      case 6: {
        if (tag == 48) {
         parse_mciConvergenceMet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mciconvergencemet_)));
          set_has_mciconvergencemet();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_testSignals;
        break;
      }

      // optional .abb.egm.EgmTestSignals testSignals = 7;
      case 7: {
        if (tag == 58) {
         parse_testSignals:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_testsignals()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_rapidExecState;
        break;
      }

      // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
      case 8: {
        if (tag == 66) {
         parse_rapidExecState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rapidexecstate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmRobot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmRobot)
  return false;
#undef DO_
}

void EgmRobot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmRobot)
  // optional .abb.egm.EgmHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  if (has_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->feedback(), output);
  }

  // optional .abb.egm.EgmPlanned planned = 3;
  if (has_planned()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->planned(), output);
  }

  // optional .abb.egm.EgmMotorState motorState = 4;
  if (has_motorstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->motorstate(), output);
  }

  // optional .abb.egm.EgmMCIState mciState = 5;
  if (has_mcistate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->mcistate(), output);
  }

  // optional bool mciConvergenceMet = 6;
  if (has_mciconvergencemet()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->mciconvergencemet(), output);
  }

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  if (has_testsignals()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->testsignals(), output);
  }

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  if (has_rapidexecstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->rapidexecstate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmRobot)
}

::google::protobuf::uint8* EgmRobot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRobot)
  // optional .abb.egm.EgmHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  if (has_feedback()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->feedback(), target);
  }

  // optional .abb.egm.EgmPlanned planned = 3;
  if (has_planned()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->planned(), target);
  }

  // optional .abb.egm.EgmMotorState motorState = 4;
  if (has_motorstate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->motorstate(), target);
  }

  // optional .abb.egm.EgmMCIState mciState = 5;
  if (has_mcistate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->mcistate(), target);
  }

  // optional bool mciConvergenceMet = 6;
  if (has_mciconvergencemet()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->mciconvergencemet(), target);
  }

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  if (has_testsignals()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->testsignals(), target);
  }

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  if (has_rapidexecstate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->rapidexecstate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRobot)
  return target;
}

int EgmRobot::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional .abb.egm.EgmFeedBack feedBack = 2;
    if (has_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->feedback());
    }

    // optional .abb.egm.EgmPlanned planned = 3;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->planned());
    }

    // optional .abb.egm.EgmMotorState motorState = 4;
    if (has_motorstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->motorstate());
    }

    // optional .abb.egm.EgmMCIState mciState = 5;
    if (has_mcistate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mcistate());
    }

    // optional bool mciConvergenceMet = 6;
    if (has_mciconvergencemet()) {
      total_size += 1 + 1;
    }

    // optional .abb.egm.EgmTestSignals testSignals = 7;
    if (has_testsignals()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->testsignals());
    }

    // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
    if (has_rapidexecstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rapidexecstate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmRobot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmRobot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmRobot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmRobot::MergeFrom(const EgmRobot& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::abb::egm::EgmHeader::MergeFrom(from.header());
    }
    if (from.has_feedback()) {
      mutable_feedback()->::abb::egm::EgmFeedBack::MergeFrom(from.feedback());
    }
    if (from.has_planned()) {
      mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(from.planned());
    }
    if (from.has_motorstate()) {
      mutable_motorstate()->::abb::egm::EgmMotorState::MergeFrom(from.motorstate());
    }
    if (from.has_mcistate()) {
      mutable_mcistate()->::abb::egm::EgmMCIState::MergeFrom(from.mcistate());
    }
    if (from.has_mciconvergencemet()) {
      set_mciconvergencemet(from.mciconvergencemet());
    }
    if (from.has_testsignals()) {
      mutable_testsignals()->::abb::egm::EgmTestSignals::MergeFrom(from.testsignals());
    }
    if (from.has_rapidexecstate()) {
      mutable_rapidexecstate()->::abb::egm::EgmRapidCtrlExecState::MergeFrom(from.rapidexecstate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmRobot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmRobot::CopyFrom(const EgmRobot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRobot::IsInitialized() const {

  if (has_feedback()) {
    if (!this->feedback().IsInitialized()) return false;
  }
  if (has_planned()) {
    if (!this->planned().IsInitialized()) return false;
  }
  if (has_motorstate()) {
    if (!this->motorstate().IsInitialized()) return false;
  }
  if (has_mcistate()) {
    if (!this->mcistate().IsInitialized()) return false;
  }
  if (has_rapidexecstate()) {
    if (!this->rapidexecstate().IsInitialized()) return false;
  }
  return true;
}

void EgmRobot::Swap(EgmRobot* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(feedback_, other->feedback_);
    std::swap(planned_, other->planned_);
    std::swap(motorstate_, other->motorstate_);
    std::swap(mcistate_, other->mcistate_);
    std::swap(mciconvergencemet_, other->mciconvergencemet_);
    std::swap(testsignals_, other->testsignals_);
    std::swap(rapidexecstate_, other->rapidexecstate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmRobot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmRobot_descriptor_;
  metadata.reflection = EgmRobot_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmSensor::kHeaderFieldNumber;
const int EgmSensor::kPlannedFieldNumber;
const int EgmSensor::kSpeedRefFieldNumber;
#endif  // !_MSC_VER

EgmSensor::EgmSensor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmSensor)
}

void EgmSensor::InitAsDefaultInstance() {
  header_ = const_cast< ::abb::egm::EgmHeader*>(&::abb::egm::EgmHeader::default_instance());
  planned_ = const_cast< ::abb::egm::EgmPlanned*>(&::abb::egm::EgmPlanned::default_instance());
  speedref_ = const_cast< ::abb::egm::EgmSpeedRef*>(&::abb::egm::EgmSpeedRef::default_instance());
}

EgmSensor::EgmSensor(const EgmSensor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensor)
}

void EgmSensor::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  planned_ = NULL;
  speedref_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmSensor::~EgmSensor() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensor)
  SharedDtor();
}

void EgmSensor::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete planned_;
    delete speedref_;
  }
}

void EgmSensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmSensor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmSensor_descriptor_;
}

const EgmSensor& EgmSensor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmSensor* EgmSensor::default_instance_ = NULL;

EgmSensor* EgmSensor::New() const {
  return new EgmSensor;
}

void EgmSensor::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_header()) {
      if (header_ != NULL) header_->::abb::egm::EgmHeader::Clear();
    }
    if (has_planned()) {
      if (planned_ != NULL) planned_->::abb::egm::EgmPlanned::Clear();
    }
    if (has_speedref()) {
      if (speedref_ != NULL) speedref_->::abb::egm::EgmSpeedRef::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmSensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmSensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_planned;
        break;
      }

      // optional .abb.egm.EgmPlanned planned = 2;
      case 2: {
        if (tag == 18) {
         parse_planned:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_speedRef;
        break;
      }

      // optional .abb.egm.EgmSpeedRef speedRef = 3;
      case 3: {
        if (tag == 26) {
         parse_speedRef:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_speedref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmSensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmSensor)
  return false;
#undef DO_
}

void EgmSensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmSensor)
  // optional .abb.egm.EgmHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // optional .abb.egm.EgmPlanned planned = 2;
  if (has_planned()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->planned(), output);
  }

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  if (has_speedref()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->speedref(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmSensor)
}

::google::protobuf::uint8* EgmSensor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensor)
  // optional .abb.egm.EgmHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // optional .abb.egm.EgmPlanned planned = 2;
  if (has_planned()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->planned(), target);
  }

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  if (has_speedref()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->speedref(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensor)
  return target;
}

int EgmSensor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional .abb.egm.EgmPlanned planned = 2;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->planned());
    }

    // optional .abb.egm.EgmSpeedRef speedRef = 3;
    if (has_speedref()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->speedref());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmSensor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmSensor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmSensor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmSensor::MergeFrom(const EgmSensor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::abb::egm::EgmHeader::MergeFrom(from.header());
    }
    if (from.has_planned()) {
      mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(from.planned());
    }
    if (from.has_speedref()) {
      mutable_speedref()->::abb::egm::EgmSpeedRef::MergeFrom(from.speedref());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmSensor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSensor::CopyFrom(const EgmSensor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensor::IsInitialized() const {

  if (has_planned()) {
    if (!this->planned().IsInitialized()) return false;
  }
  return true;
}

void EgmSensor::Swap(EgmSensor* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(planned_, other->planned_);
    std::swap(speedref_, other->speedref_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmSensor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmSensor_descriptor_;
  metadata.reflection = EgmSensor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EgmSensorPathCorr::kHeaderFieldNumber;
const int EgmSensorPathCorr::kPathCorrFieldNumber;
#endif  // !_MSC_VER

EgmSensorPathCorr::EgmSensorPathCorr()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmSensorPathCorr)
}

void EgmSensorPathCorr::InitAsDefaultInstance() {
  header_ = const_cast< ::abb::egm::EgmHeader*>(&::abb::egm::EgmHeader::default_instance());
  pathcorr_ = const_cast< ::abb::egm::EgmPathCorr*>(&::abb::egm::EgmPathCorr::default_instance());
}

EgmSensorPathCorr::EgmSensorPathCorr(const EgmSensorPathCorr& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensorPathCorr)
}

void EgmSensorPathCorr::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  pathcorr_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EgmSensorPathCorr::~EgmSensorPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensorPathCorr)
  SharedDtor();
}

void EgmSensorPathCorr::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete pathcorr_;
  }
}

void EgmSensorPathCorr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmSensorPathCorr::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EgmSensorPathCorr_descriptor_;
}

const EgmSensorPathCorr& EgmSensorPathCorr::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_2eproto();
  return *default_instance_;
}

EgmSensorPathCorr* EgmSensorPathCorr::default_instance_ = NULL;

EgmSensorPathCorr* EgmSensorPathCorr::New() const {
  return new EgmSensorPathCorr;
}

void EgmSensorPathCorr::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_header()) {
      if (header_ != NULL) header_->::abb::egm::EgmHeader::Clear();
    }
    if (has_pathcorr()) {
      if (pathcorr_ != NULL) pathcorr_->::abb::egm::EgmPathCorr::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EgmSensorPathCorr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmSensorPathCorr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pathCorr;
        break;
      }

      // optional .abb.egm.EgmPathCorr pathCorr = 2;
      case 2: {
        if (tag == 18) {
         parse_pathCorr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pathcorr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmSensorPathCorr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmSensorPathCorr)
  return false;
#undef DO_
}

void EgmSensorPathCorr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmSensorPathCorr)
  // optional .abb.egm.EgmHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  if (has_pathcorr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->pathcorr(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmSensorPathCorr)
}

::google::protobuf::uint8* EgmSensorPathCorr::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensorPathCorr)
  // optional .abb.egm.EgmHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  if (has_pathcorr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->pathcorr(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensorPathCorr)
  return target;
}

int EgmSensorPathCorr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.EgmHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional .abb.egm.EgmPathCorr pathCorr = 2;
    if (has_pathcorr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pathcorr());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmSensorPathCorr::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EgmSensorPathCorr* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EgmSensorPathCorr*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EgmSensorPathCorr::MergeFrom(const EgmSensorPathCorr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::abb::egm::EgmHeader::MergeFrom(from.header());
    }
    if (from.has_pathcorr()) {
      mutable_pathcorr()->::abb::egm::EgmPathCorr::MergeFrom(from.pathcorr());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EgmSensorPathCorr::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSensorPathCorr::CopyFrom(const EgmSensorPathCorr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensorPathCorr::IsInitialized() const {

  if (has_pathcorr()) {
    if (!this->pathcorr().IsInitialized()) return false;
  }
  return true;
}

void EgmSensorPathCorr::Swap(EgmSensorPathCorr* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(pathcorr_, other->pathcorr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EgmSensorPathCorr::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EgmSensorPathCorr_descriptor_;
  metadata.reflection = EgmSensorPathCorr_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace egm
}  // namespace abb

// @@protoc_insertion_point(global_scope)
